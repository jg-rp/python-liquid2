{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Liquid2","text":"<p>Liquid is a template language, where source text (the template) contains placeholders for variables, conditional expressions for including or excluding blocks of text, and loops for repeating blocks of text. Plus other syntax for manipulating variables and combining multiple templates into a single output.</p> <p>Python Liquid2 is a flexible, non-evaluating Liquid template engine. We cater for situations where templates change and grow with an application's user base, and the authors of those templates are potentially untrusted.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Flexible: Add to, remove or replace built-in tags and filters to suite your needs. Also choose from several built-in template loaders or define your own custom template loader.</p> </li> <li> <p>Asynchronous: For situations where you have too many templates to fit in memory or those templates change frequently, they can be loaded asynchronously from file systems, databases or over a network. Similarly, template data can be fetch lazily at render time, also asynchronously.</p> </li> <li> <p>Template inheritance: Python Liquid2 has built-in template inheritance features. As well and including or rendering a partial template, you can extend parent templates by defining template blocks.</p> </li> <li> <p>Static analysis: Python Liquid2 exposes a syntax tree for each template and built-in tools for analyzing tag, filter and variable usage. You can also extract comment text and have the option of loading and analyzing included/rendered/extended templates too.</p> </li> <li> <p>Internationalization and localization: Templates have built-in support for translator comments and extracting message catalogs, plus filters for formatting currency, dates, times and numbers for international users.</p> </li> <li> <p>Compatible: Python Liquid2 is backwards compatible with Shopify/Liquid, the original authors of the Liquid template language, with a few exceptions.</p> </li> </ul>"},{"location":"#get-started","title":"Get started","text":"<p>Have a look at the quick start guide and browse through the built-in tags and filters.</p> <p>If you're coming from Python Liquid version 1, check out the migration guide.</p>"},{"location":"environment/","title":"Liquid environments","text":"<p>TODO:</p>"},{"location":"loading_templates/","title":"Loading templates","text":""},{"location":"loading_templates/#template-loaders","title":"Template loaders","text":"<p>TODO:</p> <p>Configuring an Liquid environment with a template loader is essential if you want to use the built-in <code>{% include %}</code>, <code>{% render %}</code> or <code>{% extends %}</code> tags. Otherwise Liquid would not know where to find your templates.</p>"},{"location":"loading_templates/#caching-template-loaders","title":"Caching template loaders","text":"<p>TODO</p>"},{"location":"migration/","title":"Migration guide","text":"<p>When compared to Python Liquid version 1, Liquid2 changes both the Python API and Liquid syntax and features. Liquid2's default syntax and semantics are backwards compatible with version 1 and Shopify/Liquid, mostly.</p>"},{"location":"migration/#approach-to-compatibility-and-stability","title":"Approach to compatibility and stability","text":"<p>With Python Liquid version 1, our primary objectives were render behavior stability and Shopify/Liquid compatibility, in that order. Later we introduced <code>liquid.future.Environment</code>, which sacrificed some stability for greater Shopify/Liquid compatibility as Shopify/Liquid and our understanding of it changed.</p> <p>Now, with Python Liquid version 2, render behavior stability is still the top priority, but the default environment deliberately deviates from Shopify/Liquid in several ways, \"fixing\" and adding often requested features that Shopify can't due to their large user base and the technical debt that comes with it.</p> <p>In most cases these fixes and features are backwards compatible with Shopify/Liquid, requiring little or no modification to legacy Liquid templates. To ease transition from legacy templates to Liquid2 templates we include a <code>liquid2.shopify.Environment</code>, which is configured to include some legacy tags that didn't make it in to the default environment.</p>"},{"location":"migration/#why-is-render-stability-so-important","title":"Why is render stability so important?","text":"<p>When developing a conventional website, for example, templates are developed along side application code. Template authors and application developers might be different people or different teams, but templates are known at deployment time, and all templates can probably be parsed upfront and held in memory. In this scenario it's a pain if your template render engine introduces behavioral changes, but it's manageable.</p> <p>Python Liquid caters for situations where templates change and grow with an application's user base. Not only can templates change after the application is deployed, but the number of templates could be huge, far more than can be expected to fit in memory at one time.</p> <p>Behavioral stability is essential when application users are responsible for maintaining templates. It is impractical or unreasonable to expect authors to update their templates TODO: \u2026</p> <p>Whether shopify/Liquid compatibility is important to you or not, if you\u2019re developing a multi-tenant application where users are responsible for maintaining templates, you should seriously consider building in an opt-in upgrade path for template authors to TODO: \u2026</p>"},{"location":"migration/#new-features","title":"New features","text":"<p>The following features are new or are now built-in where they weren't before.</p> <ul> <li>More whitespace control. Along with a <code>default_trim</code> configuration option, tags and the output statement now support <code>+</code>, <code>-</code> and <code>~</code> for controlling whitespace in templates. By default, <code>~</code> will remove newlines but retain space and tab characters.</li> <li>Logical expressions now support negation with the <code>not</code> operator and grouping terms with parentheses by default.</li> <li>Ternary expressions are now available by default. For example, <code>{{ a if b else c }}</code> or <code>{{ a | upcase if b == 'foo' else c || split }}</code>.</li> <li>Inline comments surrounded by <code>{#</code> and <code>#}</code> are enabled by default. Additional <code>#</code>\u2019s can be added to comment out blocks of markup that already contain comments, as long as the number of hashes match.</li> <li>String literals are allowed to contain markup delimiters (<code>{{</code>, <code>}}</code>, <code>{%</code>, <code>%}</code>, <code>{#</code> and <code>#}</code>) and support c-like escape sequence to allow for including quote characters.</li> <li>Filter and tag named arguments can be separated by a <code>:</code> or <code>=</code>.</li> <li>Template inheritance is now built-in. Previously <code>{% extends %}</code> and <code>{% block %}</code> tags were available from a separate package.</li> <li>Internationalization and localization tags and filters are now built-in. Previously these were in a separate package.</li> <li>Templates are now serializable. Use <code>str(template)</code> or <code>pickle.dump(template)</code>.</li> <li>Error messages have been improved and exceptions include line and column numbers.</li> <li>A new test suite is included if you'd like to implement Liquid2 in another language.</li> </ul>"},{"location":"migration/#features-that-have-been-removed","title":"Features that have been removed","text":"<p>These features are not yet included in Python Liquid2, but can be if there is a demand.</p> <ul> <li>Async filters have not been implemented.</li> <li>Contextual template analysis has not been implemented.</li> <li>Template tag analysis (analyzing tokens instead of a syntax tree) has not been implemented.</li> </ul>"},{"location":"migration/#api-changes","title":"API changes","text":"<p>These are the most notable changes. Please raise an issue or start a discussion if I've missed anything or you need help with migration.</p> <ul> <li>Package level <code>Template</code> can no longer be used as a convenience function for creating a template from a string. Use <code>parse()</code> or <code>DEFAULT_ENVIRONMENT.from_string()</code> instead.</li> <li>StrictUndefined now plays nicely with the <code>default</code> filter. Previously we had a separate <code>StrictDefaultUndefined</code> class.</li> <li><code>FileSystemLoader</code> now takes an optional default file extension to use when looking for files that don't already have an extension. Previously there was a separate <code>FileExtensionLoader</code>.</li> <li><code>AwareBoundTemplate</code> (a template with a built-in <code>template</code> drop) has been removed, but can be added as a feature later if there is a demand.</li> <li>The <code>auto_reload</code> and <code>cache_size</code> arguments to <code>Environment</code> have been removed. Now caching is handle by template loaders, not the environment. For example, pass a <code>CachingFileSystemLoader</code> as the <code>loader</code> argument to <code>Environment</code> instead of a <code>FileSystemLoader</code>.</li> <li><code>TemplateNotFound</code> has been renamed to <code>TemplateNotFoundError</code>.</li> <li><code>Context</code> has been renamed to <code>RenderContext</code> and now takes a mandatory <code>template</code> argument instead of <code>env</code>. All other arguments to <code>RenderContext</code> are now keyword only.</li> </ul>"},{"location":"migration/#template-and-expression-parsing","title":"Template and expression parsing","text":"<p>The lexer has been completely rewritten and the token's it produces bare little resemblance to those produced by any of the several parsing functions from Python Liquid version 1. Now we have a single lexer that scans source text content, tags, statements and expressions in a single pass, and a parser that delegates the parsing of those tokens to classes implementing <code>Tag</code>.</p> <p>As before, <code>Tag</code> instances are responsible for returning <code>Node</code>s from <code>Tag.parse()</code>. And nodes still have the familiar <code>render_to_output()</code> abstract method.</p> <p>For now I recommend familiarizing yourself with the different <code>Token</code> classes generated by the lexer, and refer to built-in tag implementations for examples of using various <code>Expression.parse()</code> static methods to parse expressions.</p> <p>As always, open an issue or start a discussion if you need any help with migration.</p>"},{"location":"migration/#performance","title":"Performance","text":"<p>TODO:</p> <ul> <li>Benchmarks show Python Liquid2 to be more JIT friendly</li> </ul>"},{"location":"migration/#package-dependencies","title":"Package dependencies","text":"<p>The following packages are dependencies of Python Liquid2.</p> <ul> <li>Markupsafe&gt;=2</li> <li>Babel&gt;=2</li> <li>python-dateutil</li> </ul>"},{"location":"quick_start/","title":"Quick start","text":"<p>This page gets you started using Liquid with Python. See Liquid syntax for an introduction to writing Liquid templates.</p>"},{"location":"quick_start/#install","title":"Install","text":"<p>Install Python Liquid2 from PyPi using pip:</p> <pre><code>python -m pip install python-liquid2\n</code></pre> <p>Or Pipenv:</p> <pre><code>pipenv install python-liquid2\n</code></pre> <p>Or Poetry:</p> <pre><code>poetry add python-liquid2\n</code></pre>"},{"location":"quick_start/#render","title":"<code>render()</code>","text":"<p>Here's a very simple example that renders a template from a string of text with the package-level <code>render()</code> function. The template has just one placeholder variable <code>you</code>, which we've given the value <code>\"World\"</code>.</p> <pre><code>from liquid2 import render\n\nprint(render(\"Hello, {{ you }}!\", you=\"World\"))\n# Hello, World!\n</code></pre>"},{"location":"quick_start/#parse","title":"<code>parse()</code>","text":"<p>Often you'll want to render the same template several times with different variables. We can parse source text without immediately rendering it using the <code>parse()</code> function. <code>parse()</code> returns a <code>Template</code> instance with a <code>render()</code> method.</p> <pre><code>from liquid2 import parse\n\ntemplate = parse(\"Hello, {{ you }}!\")\nprint(template.render(you=\"World\"))  # Hello, World!\nprint(template.render(you=\"Liquid\"))  # Hello, Liquid!\n</code></pre>"},{"location":"quick_start/#configure","title":"Configure","text":"<p>Both <code>parse()</code> and <code>render()</code> are convenience functions that use the default Liquid environment. For all but the simplest cases you'll want to configure an instance of <code>Environment</code>, then load and render templates from that.</p> <pre><code>from liquid2 import CachingFileSystemLoader\nfrom liquid2 import Environment\n\nenv = Environment(\n    auto_escape=True,\n    loader=CachingFileSystemLoader(\"./templates\"),\n)\n</code></pre> <p>Then, using <code>env.from_string()</code> or <code>env.get_template()</code>, we can create a <code>Template</code> from a string or read from the file system, respectively.</p> <pre><code># ... continued from above\ntemplate = env.from_string(\"Hello, {{ you }}!\")\nprint(template.render(you=\"World\"))  # Hello, World!\n\n# Try to load \"./templates/index.html\"\nanother_template = env.get_template(\"index.html\")\ndata = {\"some\": {\"thing\": [1, 2, 3]}}\nresult = another_template.render(**data)\n</code></pre> <p>Unless you happen to have a relative folder called <code>templates</code> with a file called <code>index.html</code> within it, we would expect a <code>TemplateNotFoundError</code> to be raised when running the example above.</p>"},{"location":"quick_start/#whats-next","title":"What's next?","text":"<p>Read more about configuring Liquid environments, template loaders and managing render context data.</p>"},{"location":"tag_reference/","title":"Tag reference","text":""},{"location":"tag_reference/#block","title":"block","text":"<p>TODO:</p>"},{"location":"tag_reference/#extend","title":"extend","text":"<p>TODO:</p>"},{"location":"tag_reference/#include","title":"include","text":"<p>TODO:</p>"},{"location":"tag_reference/#render","title":"render","text":"<p>TODO:</p>"},{"location":"api/convenience/","title":"Convenience functions","text":""},{"location":"api/convenience/#liquid2.parse","title":"liquid2.parse","text":"<pre><code>parse(\n    source: str, globals: Mapping[str, object] | None = None\n) -&gt; Template\n</code></pre> <p>Parse source as a Liquid template using the default environment.</p> PARAMETER DESCRIPTION <code>source</code> <p>Liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>globals</code> <p>Variables that will be available to the resulting template.</p> <p> TYPE: <code>Mapping[str, object] | None</code> DEFAULT: <code>None</code> </p> Return <p>A new template bound to the default environment.</p>"},{"location":"api/convenience/#liquid2.render","title":"liquid2.render","text":"<pre><code>render(source: str, *args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>Parse and render source as a Liquid template using the default environment.</p> <p>Additional arguments are passed to <code>dict()</code> and will be available as template variables.</p> PARAMETER DESCRIPTION <code>source</code> <p>Liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>*args</code> <p>dict-like arguments added to the template render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>dict-like arguments added to the template render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Return <p>The result of rendering source as a Liquid template.</p>"},{"location":"api/convenience/#liquid2.render_async","title":"liquid2.render_async  <code>async</code>","text":"<pre><code>render_async(source: str, *args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>Parse and render source as a Liquid template using the default environment.</p> <p>Additional arguments are passed to <code>dict()</code> and will be available as template variables.</p> PARAMETER DESCRIPTION <code>source</code> <p>Liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>*args</code> <p>dict-like arguments added to the template render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>dict-like arguments added to the template render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Return <p>The result of rendering source as a Liquid template.</p>"},{"location":"api/environment/","title":"Environment","text":""},{"location":"api/environment/#liquid2.Environment","title":"liquid2.Environment","text":"<p>Template parsing and rendering configuration.</p>"},{"location":"api/environment/#liquid2.Environment.context_depth_limit","title":"context_depth_limit  <code>class-attribute</code>","text":"<pre><code>context_depth_limit: int = 30\n</code></pre> <p>Maximum number of times a render context can be extended or wrapped before raising a <code>ContextDepthError</code>.</p>"},{"location":"api/environment/#liquid2.Environment.local_namespace_limit","title":"local_namespace_limit  <code>class-attribute</code>","text":"<pre><code>local_namespace_limit: int | None = None\n</code></pre> <p>Maximum number of bytes (according to sys.getsizeof) allowed in a template's local namespace before a <code>LocalNamespaceLimitError</code> is raised. We only count the size of the namespaces values, not the size of keys/names.</p>"},{"location":"api/environment/#liquid2.Environment.loop_iteration_limit","title":"loop_iteration_limit  <code>class-attribute</code>","text":"<pre><code>loop_iteration_limit: int | None = None\n</code></pre> <p>Maximum number of loop iterations allowed before a <code>LoopIterationLimitError</code> is raised.</p>"},{"location":"api/environment/#liquid2.Environment.output_stream_limit","title":"output_stream_limit  <code>class-attribute</code>","text":"<pre><code>output_stream_limit: int | None = None\n</code></pre> <p>Maximum number of bytes that can be written to a template's output stream before raising an <code>OutputStreamLimitError</code>.</p>"},{"location":"api/environment/#liquid2.Environment.suppress_blank_control_flow_blocks","title":"suppress_blank_control_flow_blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_blank_control_flow_blocks: bool = True\n</code></pre> <p>If True (the default), indicates that blocks rendering to whitespace only will not be output.</p>"},{"location":"api/environment/#liquid2.Environment.from_string","title":"from_string","text":"<pre><code>from_string(\n    source: str,\n    *,\n    name: str = \"\",\n    path: str | Path | None = None,\n    globals: Mapping[str, object] | None = None,\n    overlay_data: Mapping[str, object] | None = None\n) -&gt; Template\n</code></pre> <p>Create a template from a string.</p>"},{"location":"api/environment/#liquid2.Environment.get_template","title":"get_template","text":"<pre><code>get_template(\n    name: str,\n    *,\n    globals: Mapping[str, object] | None = None,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; Template\n</code></pre> <p>Load and parse a template using the configured loader.</p> PARAMETER DESCRIPTION <code>name</code> <p>The template's name. The loader is responsible for interpreting the name. It could be the name of a file or some other identifier.</p> <p> TYPE: <code>str</code> </p> <code>globals</code> <p>A mapping of render context variables attached to the resulting template.</p> <p> TYPE: <code>Mapping[str, object] | None</code> DEFAULT: <code>None</code> </p> <code>context</code> <p>An optional render context that can be used to narrow the template source search space.</p> <p> TYPE: <code>RenderContext | None</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Arbitrary arguments that can be used to narrow the template source search space.</p> <p> TYPE: <code>object</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>TemplateNotFound</code> <p>If a template with the given name can not be found.</p>"},{"location":"api/environment/#liquid2.Environment.get_template_async","title":"get_template_async  <code>async</code>","text":"<pre><code>get_template_async(\n    name: str,\n    *,\n    globals: Mapping[str, object] | None = None,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; Template\n</code></pre> <p>An async version of <code>get_template()</code>.</p>"},{"location":"api/environment/#liquid2.Environment.make_globals","title":"make_globals","text":"<pre><code>make_globals(\n    globals: Mapping[str, object] | None = None\n) -&gt; dict[str, object]\n</code></pre> <p>Combine environment globals with template globals.</p>"},{"location":"api/environment/#liquid2.Environment.parse","title":"parse","text":"<pre><code>parse(source: str) -&gt; list[Node]\n</code></pre> <p>Compile template source text and return an abstract syntax tree.</p>"},{"location":"api/environment/#liquid2.Environment.setup_tags_and_filters","title":"setup_tags_and_filters","text":"<pre><code>setup_tags_and_filters() -&gt; None\n</code></pre> <p>Add tags and filters to this environment.</p> <p>This is called once when initializing an environment. Override this method in your custom environments.</p>"},{"location":"api/environment/#liquid2.Environment.trim","title":"trim","text":"<pre><code>trim(\n    text: str,\n    left_trim: WhitespaceControl,\n    right_trim: WhitespaceControl,\n) -&gt; str\n</code></pre> <p>Return text after applying whitespace control.</p>"},{"location":"api/loaders/","title":"Loaders","text":""},{"location":"api/loaders/#liquid2.loader.BaseLoader","title":"liquid2.loader.BaseLoader","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all template loaders.</p>"},{"location":"api/loaders/#liquid2.loader.BaseLoader.get_source","title":"get_source  <code>abstractmethod</code>","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>Environment</code> attempting to load the template source text.</p> <p> TYPE: <code>Environment</code> </p> <code>template_name</code> <p>A name or identifier for a template's source text.</p> <p> TYPE: <code>str</code> </p> <code>context</code> <p>An optional render context that can be used to narrow the template source search space.</p> <p> TYPE: <code>RenderContext | None</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Arbitrary arguments that can be used to narrow the template source search space.</p> <p> TYPE: <code>object</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/loaders/#liquid2.loader.BaseLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>An async version of <code>get_source</code>.</p> <p>The default implementation delegates to <code>get_source()</code>.</p>"},{"location":"api/loaders/#liquid2.loader.BaseLoader.load","title":"load","text":"<pre><code>load(\n    env: Environment,\n    name: str,\n    *,\n    globals: Mapping[str, object] | None = None,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; Template\n</code></pre> <p>Find and parse template source code.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>Environment</code> attempting to load the template source text.</p> <p> TYPE: <code>Environment</code> </p> <code>name</code> <p>A name or identifier for a template's source text.</p> <p> TYPE: <code>str</code> </p> <code>globals</code> <p>A mapping of render context variables attached to the resulting template.</p> <p> TYPE: <code>Mapping[str, object] | None</code> DEFAULT: <code>None</code> </p> <code>context</code> <p>An optional render context that can be used to narrow the template source search space.</p> <p> TYPE: <code>RenderContext | None</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Arbitrary arguments that can be used to narrow the template source search space.</p> <p> TYPE: <code>object</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/loaders/#liquid2.loader.BaseLoader.load_async","title":"load_async  <code>async</code>","text":"<pre><code>load_async(\n    env: Environment,\n    name: str,\n    *,\n    globals: Mapping[str, object] | None = None,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; Template\n</code></pre> <p>An async version of <code>load()</code>.</p>"},{"location":"api/loaders/#liquid2.loader.TemplateSource","title":"liquid2.loader.TemplateSource","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A Liquid template source as returned by the <code>get_source</code> method of a <code>loader</code>.</p> ATTRIBUTE DESCRIPTION <code>source</code> <p>The liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The liquid template file name or other string identifying its origin.</p> <p> TYPE: <code>str</code> </p> <code>uptodate</code> <p>Optional callable that will return <code>True</code> if the template is up to date, or <code>False</code> if it needs to be reloaded.</p> <p> TYPE: <code>Callable[[], bool] | Callable[[], Awaitable[bool]] | None</code> </p> <code>matter</code> <p>Optional mapping containing variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>dict[str, object] | None</code> </p>"},{"location":"api/loaders/#liquid2.FileSystemLoader","title":"liquid2.FileSystemLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A loader that loads templates from one or more directories on the file system.</p> PARAMETER DESCRIPTION <code>search_path</code> <p>One or more paths to search.</p> <p> TYPE: <code>Union[str, Path, Iterable[Union[str, Path]]]</code> </p> <code>encoding</code> <p>Encoding to use when opening files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>ext</code> <p>A default file extension. Should include a leading period.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/loaders/#liquid2.FileSystemLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid2.FileSystemLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid2.FileSystemLoader.resolve_path","title":"resolve_path","text":"<pre><code>resolve_path(template_name: str) -&gt; Path\n</code></pre> <p>Return a path to the template identified by template_name.</p> <p>If the search path is a list of paths, returns the first path where template_name exists. If none of the search paths contain template_name, a TemplateNotFound exception is raised.</p>"},{"location":"api/loaders/#liquid2.CachingFileSystemLoader","title":"liquid2.CachingFileSystemLoader","text":"<p>               Bases: <code>CachingLoaderMixin</code>, <code>FileSystemLoader</code></p> <p>A file system loader that caches parsed templates in memory.</p> PARAMETER DESCRIPTION <code>search_path</code> <p>One or more paths to search.</p> <p> TYPE: <code>Union[str, Path, Iterable[Union[str, Path]]]</code> </p> <code>encoding</code> <p>Open template files with the given encoding.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>ext</code> <p>A default file extension. Should include a leading period.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>auto_reload</code> <p>If <code>True</code>, automatically reload a cached template if it has been updated.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>namespace_key</code> <p>The name of a global render context variable or loader keyword argument that resolves to the current loader \"namespace\" or \"scope\".</p> <p>If you're developing a multi-user application, a good namespace might be <code>uid</code>, where <code>uid</code> is a unique identifier for a user and templates are arranged in folders named for each <code>uid</code> inside the search path.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>capacity</code> <p>The maximum number of templates to hold in the cache before removing the least recently used template.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p>"},{"location":"api/loaders/#liquid2.DictLoader","title":"liquid2.DictLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A loader that loads templates from a dictionary.</p> PARAMETER DESCRIPTION <code>templates</code> <p>A dictionary mapping template names to template source strings.</p> <p> TYPE: <code>dict[str, str]</code> </p>"},{"location":"api/loaders/#liquid2.DictLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get the source, filename and reload helper for a template.</p>"},{"location":"api/loaders/#liquid2.CachingDictLoader","title":"liquid2.CachingDictLoader","text":"<p>               Bases: <code>CachingLoaderMixin</code>, <code>DictLoader</code></p> <p>A <code>DictLoader</code> that caches parsed templates in memory.</p>"},{"location":"api/loaders/#liquid2.PackageLoader","title":"liquid2.PackageLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A template loader that reads templates from Python packages.</p> PARAMETER DESCRIPTION <code>package</code> <p>Import name of a package containing Liquid templates.</p> <p> TYPE: <code>Union[str, ModuleType]</code> </p> <code>package_path</code> <p>One or more directories in the package containing Liquid templates.</p> <p> TYPE: <code>Union[str, Iterable[str]]</code> DEFAULT: <code>'templates'</code> </p> <code>encoding</code> <p>Encoding of template files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>ext</code> <p>A default file extension to use if one is not provided. Should include a leading period.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'.liquid'</code> </p>"},{"location":"api/loaders/#liquid2.PackageLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid2.PackageLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid2.ChoiceLoader","title":"liquid2.ChoiceLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A template loader that delegates to other template loaders.</p> PARAMETER DESCRIPTION <code>loaders</code> <p>A list of loaders implementing <code>liquid.loaders.BaseLoader</code>.</p> <p> TYPE: <code>list[BaseLoader]</code> </p>"},{"location":"api/loaders/#liquid2.ChoiceLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid2.ChoiceLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid2.CachingChoiceLoader","title":"liquid2.CachingChoiceLoader","text":"<p>               Bases: <code>CachingLoaderMixin</code>, <code>ChoiceLoader</code></p> <p>A <code>ChoiceLoader</code> that caches parsed templates in memory.</p> PARAMETER DESCRIPTION <code>loaders</code> <p>A list of loaders implementing <code>liquid.loaders.BaseLoader</code>.</p> <p> TYPE: <code>list[BaseLoader]</code> </p> <code>auto_reload</code> <p>If <code>True</code>, automatically reload a cached template if it has been updated.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>namespace_key</code> <p>The name of a global render context variable or loader keyword argument that resolves to the current loader \"namespace\" or \"scope\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>capacity</code> <p>The maximum number of templates to hold in the cache before removing the least recently used template.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p>"},{"location":"api/template/","title":"Template","text":""},{"location":"api/template/#liquid2.Template","title":"liquid2.Template","text":"<p>A parsed template ready to be rendered.</p>"},{"location":"api/template/#liquid2.Template.analyze","title":"analyze","text":"<pre><code>analyze(\n    *, include_partials: bool = True\n) -&gt; TemplateAnalysis\n</code></pre> <p>Statically analyze this template and any included/rendered templates.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, we will try to load partial templates and analyze those templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"api/template/#liquid2.Template.analyze_async","title":"analyze_async  <code>async</code>","text":"<pre><code>analyze_async(\n    *, include_partials: bool = True\n) -&gt; TemplateAnalysis\n</code></pre> <p>An async version of <code>analyze</code>.</p>"},{"location":"api/template/#liquid2.Template.full_name","title":"full_name","text":"<pre><code>full_name() -&gt; str\n</code></pre> <p>Return this template's path, if available, joined with its name.</p>"},{"location":"api/template/#liquid2.Template.is_up_to_date","title":"is_up_to_date","text":"<pre><code>is_up_to_date() -&gt; bool\n</code></pre> <p>Return False if the template has been modified, True otherwise.</p>"},{"location":"api/template/#liquid2.Template.is_up_to_date_async","title":"is_up_to_date_async  <code>async</code>","text":"<pre><code>is_up_to_date_async() -&gt; bool\n</code></pre> <p>An async version of is_up_to_date().</p> <p>If template.uptodate is a coroutine, it wil be awaited. Otherwise it will be called just like is_up_to_date.</p>"},{"location":"api/template/#liquid2.Template.make_globals","title":"make_globals","text":"<pre><code>make_globals(\n    render_args: Mapping[str, object]\n) -&gt; Mapping[str, object]\n</code></pre> <p>Return a mapping including render arguments and template globals.</p>"},{"location":"api/template/#liquid2.Template.render","title":"render","text":"<pre><code>render(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>Render this template with args and kwargs.</p>"},{"location":"api/template/#liquid2.Template.render_async","title":"render_async  <code>async</code>","text":"<pre><code>render_async(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>Render this template with args and kwargs.</p>"},{"location":"api/template/#liquid2.Template.render_with_context","title":"render_with_context","text":"<pre><code>render_with_context(\n    context: RenderContext,\n    buf: TextIO,\n    *args: Any,\n    partial: bool = False,\n    block_scope: bool = False,\n    **kwargs: Any\n) -&gt; int\n</code></pre> <p>Render this template using an existing render context and output buffer.</p>"},{"location":"api/template/#liquid2.Template.render_with_context_async","title":"render_with_context_async  <code>async</code>","text":"<pre><code>render_with_context_async(\n    context: RenderContext,\n    buf: TextIO,\n    *args: Any,\n    partial: bool = False,\n    block_scope: bool = False,\n    **kwargs: Any\n) -&gt; int\n</code></pre> <p>Render this template using an existing render context and output buffer.</p>"},{"location":"api/template/#liquid2.static_analysis.TemplateAnalysis","title":"liquid2.static_analysis.TemplateAnalysis  <code>dataclass</code>","text":"<p>The result of analyzing a template using <code>Template.analyze()</code>.</p> PARAMETER DESCRIPTION <code>variables</code> <p>All referenced variables, whether they are in scope or not. Including references to names such as <code>forloop</code> from the <code>for</code> tag.</p> <p> TYPE: <code>dict[str, list[Variable]]</code> </p> <code>locals</code> <p>Template variables that are added to the template local scope, whether they are subsequently used or not.</p> <p> TYPE: <code>dict[str, list[Variable]]</code> </p> <code>globals</code> <p>Template variables that, on the given line number and \"file\", are out of scope or are assumed to be \"global\". That is, expected to be included by the application developer rather than a template author.</p> <p> TYPE: <code>dict[str, list[Variable]]</code> </p> <code>filters</code> <p>All filters found during static analysis.</p> <p> TYPE: <code>dict[str, list[Span]]</code> </p> <code>tags</code> <p>All tags found during static analysis.</p> <p> TYPE: <code>dict[str, list[Span]]</code> </p>"},{"location":"api/template/#liquid2.static_analysis.Variable","title":"liquid2.static_analysis.Variable  <code>dataclass</code>","text":"<p>A variable as sequence of segments that make up its path and its location.</p>"},{"location":"api/template/#liquid2.static_analysis.Span","title":"liquid2.static_analysis.Span  <code>dataclass</code>","text":"<p>The location of a variable, tag or filter in a template.</p>"}]}